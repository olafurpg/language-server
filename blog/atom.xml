<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://scalameta.org/metals/blog</id>
    <title>Metals Blog</title>
    <updated>2019-01-22T06:00:00Z</updated>
    <generator>Feed for Node.js</generator>
    <link rel="alternate" href="http://scalameta.org/metals/blog"/>
    <subtitle>The best place to stay up-to-date with the latest Metals news and events.</subtitle>
    <logo>http://scalameta.org/metals/img/scalameta-logo.png</logo>
    <rights>Copyright Â© 2019 Metals</rights>
    <entry>
        <title type="html"><![CDATA[Low-memory symbol indexing with bloom filters]]></title>
        <id>http://scalameta.org/metals/blog/2019/01/22/bloom-filters.html</id>
        <link href="http://scalameta.org/metals/blog/2019/01/22/bloom-filters.html">
        </link>
        <updated>2019-01-22T06:00:00Z</updated>
        <summary type="html"><![CDATA[<p>The latest Metals release introduces three new in-memory indexes to implement
the features &quot;find symbol references&quot; and &quot;fuzzy symbol search&quot;. Indexes are
important to provide fast response times for user requests but they come at the
price of higher memory usage. To keep memory usage low, Metals uses a data
structure called bloom filters that implements space-efficient sets. Thanks to
bloom filters, the three new indexes added in the last release use only a few
megabytes of memory even for large projects with &gt;500k lines of code.</p>
<p>In this post, we look into how Metals uses bloom filters for fast indexing with
small memory footprint. We explain what bloom filters are and how we can encode
problems like fuzzy searching to take advantage of the nice properties of bloom
filters. Finally, we evaluate these new features on a real-world project: the
<a href="https://github.com/akka/akka">Akka</a> build.</p>
]]></summary>
        <author>
            <name>Ã“lafur PÃ¡ll Geirsson</name>
            <uri>https://twitter.com/olafurpg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Metals v0.3.2]]></title>
        <id>http://scalameta.org/metals/blog/2018/12/14/iron.html</id>
        <link href="http://scalameta.org/metals/blog/2018/12/14/iron.html">
        </link>
        <updated>2018-12-14T06:00:00Z</updated>
        <summary type="html"><![CDATA[<p>We are pleased to announce the release of Metals v0.3.2. Metals is a language
server for Scala that works with VS Code, Atom, Vim, Sublime Text and Emacs.
Metals is developed at the <a href="https://scala.epfl.ch/">Scala Center</a> with
contributors from the community.</p>
]]></summary>
        <author>
            <name>Ã“lafur PÃ¡ll Geirsson</name>
            <uri>https://twitter.com/olafurpg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Fast goto definition with low memory footprint]]></title>
        <id>http://scalameta.org/metals/blog/2018/12/12/fast-goto-definition.html</id>
        <link href="http://scalameta.org/metals/blog/2018/12/12/fast-goto-definition.html">
        </link>
        <updated>2018-12-12T06:00:00Z</updated>
        <summary type="html"><![CDATA[<p>Metals throws away its navigation index when it shuts down. Next time it starts,
the index is computed again from scratch. Although this approach is simple, it
requires indexing to be fast enough so you don't mind running it again and
again. Also, because we don't persist the index to disk, we need to be careful
with memory usage.</p>
<p>This post covers how Metals achieves fast source indexing for Scala with a small
memory footprint. We describe the problem statement, explain the initial
solution and how an optimization delivered a 10x speedup. Finally, we evaluate
the result on a real-world project.</p>
]]></summary>
        <author>
            <name>Ã“lafur PÃ¡ll Geirsson</name>
            <uri>https://twitter.com/olafurpg</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Metals v0.3 - Iron]]></title>
        <id>http://scalameta.org/metals/blog/2018/12/06/iron.html</id>
        <link href="http://scalameta.org/metals/blog/2018/12/06/iron.html">
        </link>
        <updated>2018-12-06T06:00:00Z</updated>
        <summary type="html"><![CDATA[<p>We are excited to announce the release of Metals v0.3, codename &quot;Iron&quot; ðŸŽ‰ Metals
is a language server for Scala.</p>
<h2><a class="anchor" aria-hidden="true" id="tl-dr"></a><a href="#tl-dr" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>TL;DR</h2>
<ul>
<li>simple installation</li>
<li>accurate diagnostics</li>
<li>goto definition</li>
<li>text editors: Visual Studio Code, Atom, Vim and Sublime Text</li>
<li>no completions</li>
</ul>
<p>Check out the website and give Metals a try: <a href="https://scalameta.org/metals/">https://scalameta.org/metals/</a></p>
]]></summary>
        <author>
            <name>Ã“lafur PÃ¡ll Geirsson</name>
            <uri>https://twitter.com/olafurpg</uri>
        </author>
    </entry>
</feed>